uniapp 不支持 axios请求 原生wx.request 功能简单 没有拦截器等全局定制的功能,因此建议在uniapp中使用@escook/request-miniprogram	第三方包发起网络请求

@escook/request-miniprogram	

uniapp 上的顶级对象是 uni 微信上的api 都可以通过uni来进行调用


<!-- 分包 -->
分包可以减少小程序首次启动时的加载时间
为此我们在项目中 把tabbar相关的 4个页面放到主包中,其他页面(一些详情页面)放到分包当中
1~在项目跟目录中,创建分包的根目录,命名subpkg
2~在 packes.json中 , 和pages 节点平级的位置声明 subPackages 节点 , 用来定义分包相关的结构
subPackages:{
	root:根目录,
	pages:所有页面
}
3~打开subpkg文件新建页面 选择 分包

跳转路由 tabbar也会切换
uni.switchTab({url:'/pages/cate/cate'})

获取系统信息同步接口
uni.getSystemInfoSync 可以获取到当前设备的信息(设备型号什么的都有)
以及**屏幕高度** 和 **可使用的窗口高度**

uni.getSystemInfoSync() 可以获得一个对象 里面存放了 信息
这里面的windowHeight 可以获得 可用高度值

动态class
:class="['left-scroll-view-item',i === active ? 'active':'']"
class给一个数组 数组里面的值为class名 第二个active名做一个判断 是否等于当前组件中active的值
如果是的话 就给一个active 

## bug

当我们在分类页面切换一级分类的之后 二级分类列表的 滚动条可能不会 重置到顶部
所以给view-scroll标签 一个scroll-top属性  再给一个值进行控制
切换的时候 我们把scroll-top指向的变量的值变成0 就可以了 
但如果 重复赋值成同样值 会失效
所以我可以在 0 - 1 取反

<!-- 搜索防抖 -->
没有 搜索button 用户输入完搜索内容后 500毫秒后开始发送搜索请求 如果在这500毫秒内 用户又继续输入了 那么则清除上一次的 宏任务函数(setTimeout)
总结 : 每一次调用input就清除上一次的异步函数 直到用户输入完内容后 seTtimeout 才没有被清除开始调用


<!-- 搜索历史保持最新 -->
对用户输入的记录 进行保存到数组 保存到数组后 每次的搜索都会在历史记录的最前一个显示 如果搜索了以前使用过的记录 
那么那条记录则提升显示到第一条 

数组存放好词条,当用户在搜索的时候 给数组追加词条, 但是不是直接往原数组追加
而是 使用一个函数 然后new一个set类型 初始值为我们的原数组 我们删除掉我们输入值的数组元素  
然后在 给这个set实例.add(我们输入的值)追加内容 这里是为了让它在最后,以防之前存在 就不加了 set具有唯一性
然后我们再使用一个computed return 一个新数组 这个新数组 把我们的原数组 拆分 加入 然后我们再reserve 反转排序 
让最新加的词条再数组第一位,
这样我们以后再输入的时候 每次拿到的都是最新数组 
这里我们的原数组 成了一个间接数组 它用来中转存储 发生改变时 计算属性会重新计算 然后我们dom绑定计算属性就会获取到最新值
注意这里我们v-for没有使用原数组

数据持久化 
uni.getStorageSync取  uni.setStorageSync存
如果kw有的情况下则取 不然就给一个空数组
this.historyList = JSON.parse(uni.getStorageSync('kw')||'[]')

block元素和vue的template一样 渲染时不会起到任何实际的元素


uniapp的自定义组件 不需要的导入
只需要再components下 新建组件
之后就可以直接使用了


<!-- 下拉加载更多 -->
打开pages.json 配置文件 再需要使用下拉加载更多的页面 配置对象中的style对象里 
写入一个 属性 onReachBottomistance 值为距离底部的单位 
之后在对应的 组件中 写入一个函数 onReachBottom

个人理解是自定义事件